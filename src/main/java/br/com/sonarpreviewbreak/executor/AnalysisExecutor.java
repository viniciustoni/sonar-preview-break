package br.com.sonarpreviewbreak.executor;

import java.io.InputStream;
import java.text.MessageFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.maven.plugin.logging.Log;
import org.apache.maven.project.MavenProject;

import com.fasterxml.jackson.databind.ObjectMapper;

import br.com.sonarpreviewbreak.dto.IssuesDTO;
import br.com.sonarpreviewbreak.dto.PreviewDTO;
import br.com.sonarpreviewbreak.dto.QueryAnalysisDTO;
import br.com.sonarpreviewbreak.dto.ResultAnalysisDTO;
import br.com.sonarpreviewbreak.dto.ennumerated.Severity;
import br.com.sonarpreviewbreak.exception.SonarAnalysisException;
import br.com.sonarpreviewbreak.exception.SonarPreviewBreakException;
import br.com.sonarpreviewbreak.utils.SonarUtils;

/**
 * Execute the analysis on project, getting the json preview file generated by
 * sonar:sonar sonar.analysis.mode=preview and
 * sonar.report.export.path=FILE_NAME. All analysis is about report path.
 * 
 * @author Vinicius Antonio Gai
 *
 */
public class AnalysisExecutor {

	private static final String ERROR_MESSAGE_QUALITY_GATES = "Number of {0} severity is greater than {1}. Actual number is {2}";

	private final Log log;
	private final MavenProject mavenProject;

	public AnalysisExecutor(final Log log, final MavenProject mavenProject) {
		this.log = log;
		this.mavenProject = mavenProject;
	}

	/**
	 * Process the analysis of sonar.
	 * 
	 * @param queryAnalysisDTO
	 *            Data to process analysis.
	 * @return {@link ResultAnalysisDTO} with result of analysis.
	 * @throws SonarPreviewBreakException
	 */
	public ResultAnalysisDTO processAnalysis(final QueryAnalysisDTO queryAnalysisDTO) throws SonarPreviewBreakException {

		return processNewIssues(getAllNewIssues(queryAnalysisDTO.getReportPath()), queryAnalysisDTO);
	}

	/**
	 * Process new issues.
	 * 
	 * @param newIssues
	 *            List of new issues.
	 * @param queryAnalysisDTO
	 *            Data to analysis new issues.
	 * @return {@link ResultAnalysisDTO}.
	 */
	private ResultAnalysisDTO processNewIssues(final List<IssuesDTO> newIssues, final QueryAnalysisDTO queryAnalysisDTO) {

		ResultAnalysisDTO resultAnalysisDTO = ResultAnalysisDTO.createSuccess();

		if (CollectionUtils.isNotEmpty(newIssues)) {
			
			List<String> errorMessages = new ArrayList<>();
			
			analysisQualityGates(newIssues, Severity.BLOCKER, queryAnalysisDTO.getMaxBlockers(), errorMessages);
			analysisQualityGates(newIssues, Severity.CRITICAL, queryAnalysisDTO.getMaxVulnerabilities(), errorMessages);
			analysisQualityGates(newIssues, Severity.MAJOR, queryAnalysisDTO.getMaxMajors(), errorMessages);
			analysisQualityGates(newIssues, Severity.MINOR, queryAnalysisDTO.getMaxMinors(), errorMessages);
			
			if(!errorMessages.isEmpty()) {
				StringBuilder message = new StringBuilder();
				message.append(System.lineSeparator()).append(System.lineSeparator());
				for(String errorMessage : errorMessages) {
					message.append(errorMessage).append(System.lineSeparator());
				}
				resultAnalysisDTO = ResultAnalysisDTO.createError(message.toString());
			}
			
		}

		return resultAnalysisDTO;
	}

	/**
	 * analysis new issues.
	 * 
	 * @param newIssues
	 *            List of new issues.
	 * @param severity
	 *            Severity to analysis
	 * @param maxMaxIssues
	 *            Max numbers of issues
	 * @throws SonarAnalysisException
	 *             Exception throwing when number of issues greater then max
	 *             quantity;
	 */
	private void analysisQualityGates(final List<IssuesDTO> newIssues, final Severity severity, final Integer maxMaxIssues, List<String> errorMessages) {
			

		List<IssuesDTO> severityIssues = newIssues.stream().filter(issue -> severity.equals(issue.getSeverity())).collect(Collectors.toList()); 
		final long quantity = severityIssues.size();
		
		log.debug("Analysis severity: " + severity);
		log.debug("Analysis qtdMaxIssues: " + maxMaxIssues);
		log.debug("Analysis quantity: " + quantity);
		
		if (maxMaxIssues != null && quantity > maxMaxIssues.longValue()) {
			
			this.logNewIssues(severityIssues, severity);
			
			errorMessages.add(MessageFormat.format(ERROR_MESSAGE_QUALITY_GATES, severity.name(), maxMaxIssues, quantity));
		}
	}

	/**
	 * Get all new issues.
	 * 
	 * @param jsonFileName
	 *            Name os json to analysis.
	 * @return List of new issues.
	 */
	private List<IssuesDTO> getAllNewIssues(final String jsonFileName) throws SonarPreviewBreakException {

		List<IssuesDTO> newIssuesDTOs = null;

		final PreviewDTO previewDTO = getPreviewDTO(jsonFileName);
		
		log.debug("PreviewDTO: " + previewDTO);
		if (previewDTO != null && CollectionUtils.isNotEmpty(previewDTO.getIssues())) {
			
			log.debug("Tem Issues: ");
			newIssuesDTOs = previewDTO.getIssues().stream().filter(issue -> issue.isNew()).distinct().collect(Collectors.toList());
			log.debug("Novas issues: " + newIssuesDTOs);
		}

		return newIssuesDTOs;

	}

	/**
	 * Load json file and convert to {@link PreviewDTO}
	 * 
	 * @param jsonFileName
	 *            Json File name.
	 * @return {@link PreviewDTO}
	 * @throws SonarPreviewBreakException
	 */
	private PreviewDTO getPreviewDTO(final String jsonFileName) throws SonarPreviewBreakException {

		try {
			final ObjectMapper mapper = new ObjectMapper();
			mapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"));

			log.debug("File Name: " + jsonFileName);
			
			final InputStream jsonFile = SonarUtils.getJsonPreviewFile(mavenProject, jsonFileName);

			return mapper.readValue(jsonFile, PreviewDTO.class);
		} catch (Exception e) {
			log.error("Erro to convert json to PreviewDTO", e);

			throw new SonarPreviewBreakException("Erro to convert json to PreviewDTO", e);
		}

	}
	
	/**
	 * Log issues
	 * @param issues
	 */
	private void logNewIssues(final List<IssuesDTO> issues, final Severity severity){
		
		StringBuilder builder = new StringBuilder();
		
		builder.append(System.lineSeparator())
			.append(System.lineSeparator())
			.append("------------- " + severity + " Issues  --------------------").append(System.lineSeparator())
			.append(System.lineSeparator());
		
		for(IssuesDTO issue : issues) {

			builder.append(issue.getSeverity()).append(": ").append(issue.getMessage()).append(System.lineSeparator());
			builder.append(issue.getComponent().split(":")[2]).append(" at line ").append(issue.getLine()).append(System.lineSeparator())
				.append(System.lineSeparator());
			
		}
		
		builder.append("-------------------------------------------").append(System.lineSeparator());
		
		log.info(builder.toString());
		
	}

}
